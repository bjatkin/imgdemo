package find

import (
	"image"
	"image/color"
	"reflect"
	"testing"
)

func Test_findData(t *testing.T) {
	type args struct {
		image *image.NRGBA
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
		want    []byte
	}{
		{
			name: "find data",
			args: args{
				image: newTestImage([...]color.RGBA{
					{0xA0, 0xB0, 0xC0, 0xD1}, {0xA0, 0xB0, 0xC1, 0xD1}, {0xA0, 0xB0, 0xC1, 0xD1}, {0xA0, 0xB1, 0xC1, 0xD1},
					{0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC1, 0xD0},
					{0xA1, 0xB1, 0xC0, 0xD1}, {0xA0, 0xB0, 0xC0, 0xD1}, {0xA0, 0xB0, 0xC0, 0xD1}, {0xA1, 0xB0, 0xC0, 0xD1},
					{0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0},
				}),
			},
			wantErr: false,
			want:    []byte{0b1101_0001, 0b0001_1001},
		},
		{
			name: "missing magic number",
			args: args{
				image: newTestImage([...]color.RGBA{
					{0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0},
					{0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC1, 0xD0},
					{0xA1, 0xB1, 0xC0, 0xD1}, {0xA0, 0xB0, 0xC0, 0xD1}, {0xA0, 0xB0, 0xC0, 0xD1}, {0xA1, 0xB0, 0xC0, 0xD1},
					{0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0}, {0xA0, 0xB0, 0xC0, 0xD0},
				}),
			},
			wantErr: true,
			want:    nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := findData(tt.args.image)
			if (err != nil) != tt.wantErr {
				t.Errorf("FindData(): want error %v got error %v", tt.wantErr, err)
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("FindData(): retrived messages do not match")
			}
		})
	}
}

func newTestImage(colors [16]color.RGBA) *image.NRGBA {
	shape := 4
	img := image.NewNRGBA(image.Rect(0, 0, shape, shape))
	for y := 0; y < shape; y++ {
		for x := 0; x < shape; x++ {
			img.Set(x, y, colors[x+y*shape])
		}
	}

	return img
}
